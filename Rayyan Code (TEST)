import sys

def read_input(filename):
    config = {'process': []}
    with open(filename, 'r') as file:
        for line in file:
            parts = line.split()
            if parts[0] == 'processcount':
                config['processcount'] = int(parts[1])
            elif parts[0] == 'runfor':
                config['runfor'] = int(parts[1])
            elif parts[0] == 'use':
                config['use'] = parts[1]
            elif parts[0] == 'quantum':
                config['quantum'] = int(parts[1])
            elif parts[0] == 'process':
                name = parts[2].split('=')[1]
                arrival = int(parts[3].split('=')[1])
                burst = int(parts[4].split('=')[1])
                config['process'].append({'name': name, 'arrival': arrival, 'burst': burst})
    return config

def fifo_scheduling(processes):
    current_time = 0
    timeline = []
    for process in sorted(processes, key=lambda x: x['arrival']):
        if current_time < process['arrival']:
            timeline.append({'event': 'idle', 'time': current_time, 'duration': process['arrival'] - current_time})
            current_time = process['arrival']
        timeline.append({'event': 'selected', 'process': process['name'], 'time': current_time})
        current_time += process['burst']
        timeline.append({'event': 'finished', 'process': process['name'], 'time': current_time})
    return timeline

def sjf_preemptive_scheduling(processes):
    current_time = 0
    ready_queue = []
    running_process = None
    timeline = []
    while processes or ready_queue or running_process:
        while processes and processes[0]['arrival'] <= current_time:
            ready_queue.append(processes.pop(0))
            ready_queue.sort(key=lambda x: x['burst'])
        if running_process and ready_queue and ready_queue[0]['burst'] < running_process['burst']:
            ready_queue.append(running_process)
            running_process = None
        if not running_process and ready_queue:
            running_process = ready_queue.pop(0)
            timeline.append({'event': 'selected', 'process': running_process['name'], 'time': current_time})
        if running_process:
            running_process['burst'] -= 1
            if running_process['burst'] == 0:
                timeline.append({'event': 'finished', 'process': running_process['name'], 'time': current_time + 1})
                running_process = None
        current_time += 1
    return timeline

def round_robin_scheduling(processes, quantum):
    current_time = 0
    ready_queue = []
    timeline = []
    response_recorded = {}
    while processes or ready_queue:
        for process in [p for p in processes if p['arrival'] == current_time]:
            ready_queue.append(process)
            timeline.append({'event': 'arrived', 'process': process['name'], 'time': current_time})
        if ready_queue:
            current_process = ready_queue.pop(0)
            if current_process['name'] not in response_recorded:
                timeline.append({'event': 'selected', 'process': current_process['name'], 'time': current_time})
                response_recorded[current_process['name']] = current_time
            actual_quantum = min(quantum, current_process['burst'])
            current_process['burst'] -= actual_quantum
            current_time += actual_quantum
            if current_process['burst'] > 0:
                ready_queue.append(current_process)
            else:
                timeline.append({'event': 'finished', 'process': current_process['name'], 'time': current_time})
        else:
            timeline.append({'event': 'idle', 'time': current_time})
            current_time += 1
    return timeline

def calculate_metrics(events):
    metrics = {}
    start_times = {}
    for event in events:
        if event['event'] in ['selected', 'finished']:
            proc = event['process']
            if proc not in metrics:
                metrics[proc] = {'start': float('inf'), 'finish': None}
            if event['event'] == 'selected' and metrics[proc]['start'] == float('inf'):
                metrics[proc]['start'] = event['time']
            if event['event'] == 'finished':
                metrics[proc]['finish'] = event['time']
    for proc in metrics:
        metrics[proc]['turnaround'] = metrics[proc]['finish'] - metrics[proc]['start']
        metrics[proc]['waiting'] = metrics[proc]['turnaround'] - (metrics[proc]['finish'] - metrics[proc]['start'])
        metrics[proc]['response'] = metrics[proc]['start'] - [e['time'] for e in events if e['event'] == 'arrived' and e['process'] == proc][0]
    return metrics

def write_output(filename, events, metrics):
    output_filename = filename.rsplit('.', 1)[0] + '.out'
    with open(output_filename, 'w') as file:
        for event in events:
            if event['event'] == 'idle':
                file.write(f"Time {event['time']}-{event['time'] + event['duration']}: CPU is idle.\n")
            else:
                file.write(f"Time {event['time']}: Process {event['process']} {event['event']}.\n")
        file.write("\nProcess Metrics:\n")
        for proc, m in metrics.items():
            file.write(f"{proc}: Turnaround {m['turnaround']}, Waiting {m['waiting']}, Response {m['response']}\n")

def main():
    if len(sys.argv) != 2:
        print("Usage: python scheduler-gpt.py <inputfile>")
        return
    input_file = sys.argv[1]
    config = read_input(input_file)
    if config['use'] == "fifo":
        events = fifo_scheduling(config['process'])
    elif config['use'] == "sjf":
        events = sjf_preemptive_scheduling(config['process'])
    elif config['use'] == "rr":
        if 'quantum' not in config:
            print("Error: Quantum is required for round robin scheduling.")
            return
        events = round_robin_scheduling(config['process'], config['quantum'])
    else:
        print(f"Error: Unsupported scheduling algorithm '{config['use']}'")
        return
    metrics = calculate_metrics(events)
    write_output(input_file, events, metrics)
    print("Scheduling simulation complete. Results written to output file.")

if __name__ == "__main__":
    main()
